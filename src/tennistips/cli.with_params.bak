# -*- coding: utf-8 -*-
"""
CLI for tennistips (signature-agnostic).
It inspects generate_tips/build_features and maps args by name.
"""
from __future__ import annotations

import argparse
import os
import sys
import inspect
from typing import Optional
import pandas as pd

# Optional project helpers
try:
    from .data import load_matches as _load_matches
except Exception:
    _load_matches = None

try:
    from .config import load_config as _load_config
except Exception:
    _load_config = None

def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(prog="src.tennistips.cli", description="CLI for tennis-bot-tipster")
    sub = parser.add_subparsers(dest="cmd", required=True)
    p = sub.add_parser("tips", help="Generate tips from history and fixtures")
    p.add_argument("--history", required=True, help="CSV with match history")
    p.add_argument("--fixtures", required=True, help="CSV with prepared fixtures")
    p.add_argument("--config", required=False, default=None, help="Config file (YAML or project loader)")
    p.add_argument("--model-path", dest="model_path", required=False, default=None, help="Model path (e.g., models/model.joblib)")
    p.add_argument("--out", required=True, help="Output CSV for tips")
    return parser

def _read_history(path: str) -> pd.DataFrame:
    if _load_matches is not None:
        return _load_matches(path)
    return pd.read_csv(path)

def _read_fixtures(path: str) -> pd.DataFrame:
    return pd.read_csv(path)

def _to_namespace(obj):
    from types import SimpleNamespace
    if isinstance(obj, dict):
        return SimpleNamespace(**{k: _to_namespace(v) for k, v in obj.items()})
    if isinstance(obj, list):
        return [_to_namespace(x) for x in obj]
    return obj

def _load_cfg(config_path: Optional[str]):
    if not config_path:
        return None
    if _load_config is not None:
        return _load_config(config_path)
    try:
        import yaml  # type: ignore
    except Exception as e:
        raise RuntimeError("PyYAML not installed and project does not provide a config loader. `pip install pyyaml`") from e
    with open(config_path, "r", encoding="utf-8") as f:
        data = yaml.safe_load(f) or {}
    return _to_namespace(data)

def _smart_call(func, history_df, fixtures_df, cfg, config_path, model_path):
    """
    Call `func` by matching parameter names dynamically.
    Prefers cfg for config-like params; falls back to config_path if needed.
    """
    sig = inspect.signature(func)
    params = sig.parameters

    # Primary mapping (cfg preferred)
    mapping_primary = {
        "history": history_df, "history_df": history_df, "hist": history_df, "matches": history_df, "df_history": history_df, "df_hist": history_df,
        "fixtures": fixtures_df, "fixtures_df": fixtures_df, "fx": fixtures_df, "df_fixtures": fixtures_df,
        "config": cfg if cfg is not None else config_path,
        "cfg": cfg, "conf": cfg, "settings": cfg, "config_obj": cfg, "config_dict": cfg,
        "config_path": config_path,
        "model_path": model_path, "model": model_path, "model_file": model_path
    }

    kwargs = {}
    for name in params:
        if name in mapping_primary and mapping_primary[name] is not None:
            kwargs[name] = mapping_primary[name]

    try:
        return func(**kwargs)
    except TypeError:
        # Secondary attempt: if we passed cfg into a "config" param and it failed, try config_path instead.
        if ("config" in params) and (cfg is not None):
            kwargs2 = dict(kwargs)
            kwargs2["config"] = config_path
            return func(**kwargs2)
        raise

def _generate_tips(history_df: pd.DataFrame, fixtures_df: pd.DataFrame, config_path: Optional[str], model_path: Optional[str]) -> pd.DataFrame:
    cfg = _load_cfg(config_path)

    # Preferred entrypoint
    try:
        from .tips import generate_tips  # type: ignore
        return _smart_call(generate_tips, history_df, fixtures_df, cfg, config_path, model_path)
    except Exception:
        pass

    # Fallback: build_features + optional model
    from .features import build_features  # type: ignore
    X = _smart_call(build_features, history_df, fixtures_df, cfg, config_path, model_path)

    if model_path:
        import joblib
        model = joblib.load(model_path)
        if hasattr(model, "predict_proba"):
            proba = model.predict_proba(X)[:, 1]
        else:
            proba = model.predict(X)
        out_df = fixtures_df.copy()
        out_df["pred_prob"] = proba
        return out_df

    return X if isinstance(X, pd.DataFrame) else fixtures_df

def cmd_tips(args: argparse.Namespace) -> int:
    history_df = _read_history(args.history)
    fixtures_df = _read_fixtures(args.fixtures)
    tips_df = _generate_tips(history_df, fixtures_df, args.config, args.model_path)
    out_dir = os.path.dirname(args.out) or "."
    os.makedirs(out_dir, exist_ok=True)
    tips_df.to_csv(args.out, index=False)
    print(f"[tips] written: {len(tips_df)} rows -> {args.out}")
    return 0

def main(argv: Optional[list[str]] = None) -> int:
    parser = build_parser()
    args = parser.parse_args(argv)
    if args.cmd == "tips":
        return cmd_tips(args)
    parser.print_help()
    return 1

if __name__ == "__main__":
    sys.exit(main())
